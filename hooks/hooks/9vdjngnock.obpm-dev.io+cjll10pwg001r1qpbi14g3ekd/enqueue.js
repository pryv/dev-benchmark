module.exports = { id: 'enqueue',
  name: 'Enqueue-measurements',
  active: 'on',
  timeout: 5000,
  maxFail: 10,
  on: [ 'eventsChanged', 'load', 'timer' ],
  processes: 
   [ { name: 'fetch-data',
       code: '\n\n      rescheduleOrFetch();\n\n      function rescheduleOrFetch() {\n        var timedExecutionAt = persistentState.system.timedExecutionAt;\n        var earliestExecutionAt = persistentState.user.earliestExecutionAt;\n        var now = Date.now() / 1000;\n\n        if (earliestExecutionAt && (now < earliestExecutionAt)) {\n          // do nothing\n          log = \'already rescheduled. timedExecutionAt = \' + timedExecutionAt + \', earliesExecutionAt = \' +\n            earliestExecutionAt;\n          return;\n        }\n\n        persistentState.system.timedExecutionAt = null;\n\n        if (rateLimiter.isOverloaded()) {\n          log = \'overloaded, \';\n\n          var BASE_DELAY = 5;\n          var JITTER_DELAY = 5;\n\n          timedExecutionAt = now + BASE_DELAY + (Math.random() * JITTER_DELAY);\n          log+= \'rescheduling to \' + timedExecutionAt;\n\n          var ALLOWED_DELTA = 1;\n          persistentState.system.timedExecutionAt = timedExecutionAt;\n          persistentState.user.earliestExecutionAt = timedExecutionAt - ALLOWED_DELTA;\n          return;\n        }\n\n        log = \'fetching events\';\n        batch = [\n          {\n            method: \'events.get\',\n            params: {\n              limit: 1000,\n              streams: [persistentState.system.INPUT_STREAM_ID],\n              types: [persistentState.system.INPUT_TYPE],\n              sortAscending: true,\n              tags: [persistentState.system.TO_PROCESS_TAG]\n            }\n          }\n        ];\n      }\n    ' },
     { name: 'send-data-to-process',
       code: '\n      log = \'\';\n      if (processesResults[\'fetch-data\'].error) {\n        log = \'error fetching data: \' + processesResults[\'fetch-data\'].error;\n      }\n\n      if (processesResults[\'fetch-data\'].batchResult) {\n        sendData()\n      } else {\n        // do nothing\n      }\n\n      function sendData() {\n        var batchResponseBody = JSON.parse(processesResults[\'fetch-data\'].batchResult.body);\n\n\n        var events = batchResponseBody.results[0].events;\n        var length = events.length;\n        log += \', fetched \' + length + \' events\';\n        var jobs = [];\n        for (var i=0; i<length; i++) {\n          log += \', checking \' + printEvent(events[i]);\n\n          if (duplicatesChecker.isInCache(events[i].id)) {\n            log += \' - dropped because in cache\';\n            continue;\n          }\n\n          if (events[i].tags.indexOf(persistentState.system.FAULTY_TAG) >= 0) {\n            log += \' - dropped because faulty\';\n            continue;\n          }\n\n          if (! rateLimiter.allocJob()) {\n            log += \', rateLimiter full\';\n            log += \', events dropped: \' + (length - i);\n            break;\n          }\n\n          duplicatesChecker.mark(events[i].id);\n\n          log += \', pushing event with id=\' + events[i].id;\n          jobs.push({\n            username: pryvEnv.username,\n            token: pryvEnv.appAccess,\n            domain: pryvEnv.domain,\n            eventId: events[i].id\n          })\n        }\n\n        log += \', events sent: \' + jobs.length;\n\n        if (jobs.length > 0) {\n          httpRequest = {\n            ssl: false,\n            host: persistentState.system.queue.hostname,\n            path: persistentState.system.queue.path,\n            port: persistentState.system.queue.port,\n            headers: persistentState.system.queue.headers,\n            method: \'POST\',\n            body: JSON.stringify({jobs: jobs})\n          };\n        }\n      }\n\n\n      function printEvent(e) {\n        return \'{id:\' + e.id + \',time:\' + e.time + \',tags:\' + e.tags + \'}\';\n      }\n    ' },
     { name: 'print-http-request-result',
       code: '\n      if (processesResults[\'send-data-to-process\'].httpResult) {\n        const response = processesResults[\'send-data-to-process\'].httpResult;\n        const body = JSON.parse(response.body);\n        log = \'http request status: \' + response.statusCode\n          + \'\\n\' + \'body: \' + response.body;\n        rateLimiter.notify(body.rateLimiter.rate,\n          body.rateLimiter.errors);\n      }\n    ' } ],
  processError: null };